// тип стенда по-умолчанию может быть переопределён параметром к скрипту
// gradle -Pproject.ext.stand_type=prod
project.ext.stand_type='test'
project.ext.stand_dir='test'

// загрузить properties в зависимости от типа стенда
def loadStandProperties(type) {
	Properties props = new Properties()
	def name = "${projectDir}/deployment/config/${type}.properties"
	if (new File(name).exists()) {
		props.load(new FileInputStream(name))
	}
	if (project.ext.stand_type == 'test') {
		props.deploy_dir = props.deploy_dir + "_${System.currentTimeMillis()}"
		props.data_dir = props.deploy_dir + "/data"
		props.logs_dir = props.deploy_dir + "/logs"
	}
	return  props;
}

/*
метод для чтения свойств тестового стенда и присвоения их
расширенным свойствам проекта "stand"
WARN: метод используется в связке  "tasks.whenTaskAdded { Task task ->"
для решения проблемы
"Cannot get property 'stand' on extra properties extension as it does not exist"
на фазе конфигурирования gradle скрипта
*/
def readConfigurationMethod () {
	// проверка на предыдущую инициализацию
	if (project.ext.has('stand')) return;
	def props = loadStandProperties(project.ext.stand_type)
    project.ext.stand = props
}

// обработчик вызывающий метод при каждом определении задачи
tasks.whenTaskAdded { Task task ->
    readConfigurationMethod()
}

// create stand directory and store fullpath to 'project.ext.stand_dir'
task createStandDir {
	println "Create stand deploy dir '${project.ext.stand.deploy_dir}'"
	def dir = new File(project.ext.stand.deploy_dir);
	dir.mkdirs();
	println "Create stand logs dir '${project.ext.stand.logs_dir}'"
	dir = new File(project.ext.stand.logs_dir);
	dir.mkdirs();
	println "Create stand data dir '${project.ext.stand.data_dir}'"
	dir = new File(project.ext.stand.data_dir);
	dir.mkdirs();
}

task provisionMongoDBCopyDockerfile(type: Copy, dependsOn: ['createStandDir']) {
	from "${projectDir}/deployment/templates"
    into project.ext.stand.deploy_dir
    expand(project.ext.stand)
	filteringCharset = 'UTF-8'
}

task provisionMongoDB (dependsOn: ['provisionMongoDBCopyDockerfile']) {

}

task provisionContainers (dependsOn: ['provisionMongoDB']){

}

task startContainers (dependsOn: 'provisionContainers'){
}

task runStand (dependsOn: ['startContainers']) {
	description "выполнить развертывание"
}


// create per project files
allprojects {
	def prj = it
	// don't create these tasks for non-java projects (for this time)
	if (!prj.ext.has("isJavaProject") ) return;

	task gitByTagVersion(type:Exec)  {
		// def props = loadProjectProperties(prj)
		description "Create tag in local git by version in file"
		workingDir prj.projectDir
		//on linux
		commandLine "git",  "tag", "${prj.version}", "--message=Gradle Release at ${new Date()}"
	}

	// execute only in execution phase
	gitByTagVersion.doFirst {
		if(prj.version.endsWith('-SNAPSHOT')) {
			def msg = "Cannot create release with version: ${prj.version}"
			logger.error(msg)
			throw new IllegalStateException(msg)
		}
  	}

	task gitPush(type:Exec) {
		description "Push tag in remote storage"
  		workingDir prj.projectDir
  		//on linux
  		commandLine "git",  "push" , "origin", "--tags"
  	}

	// **** uploading
	// upload to nexus/artifactory
	apply plugin: 'maven-publish'
	publishing {
	    publications {
	        mavenJava(MavenPublication) {
				groupId 'ru.nlp_project.story_line2'
            	artifactId artifactId
				version prj.version
	            from components.java
	        }
	    }
		repositories {
	        maven {
	            credentials {
	                username "deployment"
					password "deployment"
	            }
	            if(project.version.endsWith('-SNAPSHOT')) {
	                url "http://192.168.1.99:8082/nexus/content/repositories/snapshots/"
	            } else {
	                url "http://192.168.1.99:8082/nexus/content/repositories/releases/"
	            }
	        }
	    }
	}

	publishToMavenLocal.dependsOn build
	task install (dependsOn: publishToMavenLocal) {
		description "Install in local repo"
	}

	task deploy (dependsOn: publish) {
		description "Install in remote repo"
	}

	gitByTagVersion.dependsOn build
	gitPush.dependsOn gitByTagVersion
	task release (dependsOn: [gitPush, publish]) {
		description "Make release of module (assign tag, push tag to git, publish)"
	}


}
